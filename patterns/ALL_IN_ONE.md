# Camunda 7 to 8 Code Conversion Patterns 
  
Automatically generated file containing all patterns from all sub folders in one document.
It is intended for quick reference and overview of all available patterns.
Do not edit this file manually, it is overwritten by a Github Action on every commit.

Patterns:

- [General thoughts and changes](#general-thoughts-and-changes)
  - [Maven dependency and configuration](#maven-dependency-and-configuration)
  - [Handling Process Variables](#handling-process-variables)
- [Client code](#client-code)
  - [`ProcessEngine`](#processengine)
    - [Class-level Changes](#class-level-changes)
    - [Broadcast Signals](#broadcast-signals)
    - [Cancel Process Instance](#cancel-process-instance)
    - [Correlate Messages](#correlate-messages)
    - [Handle Variables](#handle-variables)
    - [Handle Resources](#handle-resources)
    - [handle user tasks](#handle-user-tasks)
    - [Raise Incidents](#raise-incidents)
    - [Search Process Definitions](#search-process-definitions)
    - [Starting Process Instances](#starting-process-instances)
- [Glue code](#glue-code)
  - [JavaDelegate (Spring) &#8594; Job Worker (Spring)](#javadelegate-spring-8594-job-worker-spring)
    - [Class-level Changes](#class-level-changes)
    - [Handling a BPMN error](#handling-a-bpmn-error)
    - [Handling a Failure](#handling-a-failure)
    - [Handling an Incident](#handling-an-incident)
    - [Handling Process Variables](#handling-process-variables)
  - [External Task Worker (Spring) &#8594; Job Worker (Spring)](#external-task-worker-spring-8594-job-worker-spring)
    - [Class-level Changes](#class-level-changes)
    - [Handling a BPMN error](#handling-a-bpmn-error)
    - [Handling a Failure](#handling-a-failure)
    - [Handling an Incident](#handling-an-incident)
    - [Handling Process Variables](#handling-process-variables)
- [Test Code](#test-code)
  - [Camunda Platform Assert &#8594; Camunda Process Test (CPT)](#camunda-platform-assert-8594-camunda-process-test-cpt)
    - [Complete Test Case](#complete-test-case)
    - [Process Instance Assertions](#process-instance-assertions)
    - [Process Variable Assertions](#process-variable-assertions)
    - [User Task Assertions](#user-task-assertions)
    - [Message Correlation](#message-correlation)
    - [Job Execution in Test Cases](#job-execution-in-test-cases)

## General thoughts and changes

Some changes need to happen on a development-project-wide level.


### Maven dependency and configuration

As part of the code migration, remove all Camunda 7 dependencies. Import the **Camunda Spring SDK**:

```
<dependency>
	<groupId>io.camunda</groupId>
	<artifactId>spring-boot-starter-camunda-sdk</artifactId>
	<version>{version}</version>
</dependency>
```

Also, configure your the connection to the Camunda 8 cluster in the `application.properties` or `application.yaml`.

---

### Handling Process Variables

Handling of process variables in Camunda 7 is a complex topic. The engine supports various value types: primitive types like boolean, bytes, integer and string; file; object; and json and xml representations. The client code and glue code can specify how the variables are stored in the engine database. Camunda 7 offers two approaches to handle process variables: the [Java Object API](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#java-object-api), and the [Typed Value API](https://docs.camunda.org/manual/latest/user-guide/process-engine/variables/#typed-value-api). Both approaches can be used at the same time.

In Camunda 8, all common value types are stored in JSON representation. This simplifies various aspects about handling process variables in client code and glue code.

The code conversion examples cover both Camunda 7 approaches to handle process variables. Naturally, both approaches are converted into the simplified JSON representation approach in Camunda 8.

TODO: Add proper links to:

* [Process variables in client code](https://github.com/camunda-community-hub/camunda-7-to-8-code-conversion/blob/conversion-pattern/patterns/20-client-code/10-process-engine/handle-process-variables.md)
* [Process variables in glue code (Java Delegate)](https://github.com/camunda-community-hub/camunda-7-to-8-code-conversion/blob/conversion-pattern/patterns/30-glue-code/10-java-spring-delegate/handling-process-variables.md)
* [Process variables in glue code (External Task Worker)](https://github.com/camunda-community-hub/camunda-7-to-8-code-conversion/blob/conversion-pattern/patterns/30-glue-code/20-java-spring-external-task-worker/handling-process-variables.md)

---

## Client code

Whenever your solutions calls the Camunda API, e.g., to start new process instances.


### `ProcessEngine`

The ProcessEngine offers various services (think RuntimeService) to interact with the Camunda 7 engine.

The specific services are:

- RepositoryService: Manages Deployments
- RuntimeService: For starting and searching ProcessInstances
- TaskService: Exposes operations to manage human (standalone) Tasks, such as claiming, completing and assigning tasks
- IdentityService: Used for managing Users, Groups and the relations between them
- ManagementService: Exposes engine admin and maintenance operations, which have no relation to the runtime execution of business processes
- HistoryService: Exposes information about ongoing and past process instances
- FormService: Access to form data and rendered forms for starting new process instances and completing tasks

The different methods of these services are grouped into separated .md files by action, such as starting a process instance, with multiple examples covering different methods of performing the same action.


###### OpenRewrite recipe (WIP)

-   [Recipe "ProcessEngineToZeebeClient"](../recipes/src/main/java/org/camunda/migration/rewrite/recipes/client/ProcessEngineToZeebeClient.java)
-   [Learn how to apply recipes](../recipes/)


#### Class-level Changes

The code conversion patterns will focus on method-level changes. All class-level changes are described below.

###### Camunda 7: Class with autowired ProcessEngine

In Camunda 7, all engine services can be accessed via the _ProcessEngine_ interface. To interact with the engine services, create a class and inject the engine via the _@Autowired_ annotation.

```java
@Component
public class SomeClass {

    @Autowired
    private ProcessEngine engine;

    // methods can access the engine's services
}
```

###### Camunda 8: Class with autowired CamundaClient

The setup is the same in Camunda 8. The interface is called _CamundaClient_.

```java
@Component
public class SomeClass {

    @Autowired
    private CamundaClient camundaClient;

    // methods can access the client's methods
}
```

---

#### Broadcast Signals

The following patterns focus on methods how to broadcast signals in Camunda 7 and how they convert to Camunda 8.

###### ProcessEngine (Camunda 7)

```java
    public void broadcastSignalGlobally(String signalName, VariableMap variableMap) {
        engine.getRuntimeService().signalEventReceived(signalName, variableMap);
    }
```

-   signal is correlated to all suitable signal subscriptions

```java
    public void broadcastSignalToOneExecution(String signalName, String executionId, VariableMap variableMap) {
        engine.getRuntimeService().signalEventReceived(signalName, executionId, variableMap);
    }
```

-   signal is correlated to a specific executionId

```java
    public void broadcastSignalGloballyViaBuilder(String signalName, String tenantId, VariableMap variableMap) {
        engine.getRuntimeService().createSignalEvent(signalName)
                .tenantId(tenantId)
                .setVariables(variableMap)
                .send();
    }
```

-   tenantId can only be added via builder

```java
    public void broadcastSignalToOneExecutionViaBuilder(String signalName, String executionId, String tenantId, VariableMap variableMap) {
        engine.getRuntimeService().createSignalEvent(signalName)
                .executionId(executionId)
                .tenantId(tenantId)
                .setVariables(variableMap)
                .send();
    }
```

-   signal is correlated to a specific executionId
-   tenantId can only be added via builder

###### CamundaClient (Camunda 8)

```java
    public BroadcastSignalResponse broadcastSignal(String signalName, String tenantId, Map<String, Object> variableMap) {
        return camundaClient.newBroadcastSignalCommand()
                .signalName(signalName)
                .tenantId(tenantId)
                .variables(variableMap)
                .send()
                .join(); // add reactive response and error handling instead of join()
```

-   in Camunda 8, a signal is always correlated to all suitable signal subscriptions
-   to complete a specific signal event in a running process instance without broadcasting a global signal, use the [Modify process instance API](https://docs.camunda.io/docs/next/apis-tools/camunda-api-rest/specifications/modify-process-instance/)

---

#### Cancel Process Instance

The following patterns focus on methods how to cancel process instances in Camunda 7 and how they convert to Camunda 8.

###### ProcessEngine (Camunda 7)

```java
    public void cancelProcessInstance(String processInstanceId, String deleteReason) {
        engine.getRuntimeService().deleteProcessInstance(processInstanceId, deleteReason);
    }
```

```java
    public void cancelProcessInstances(List<String> processInstanceIds, String deleteReason, boolean skipCustomListeners, boolean externallyTerminated) {
        engine.getRuntimeService().deleteProcessInstances(processInstanceIds, deleteReason, skipCustomListeners, externallyTerminated);
    }
```

```java
    public Batch cancelProcessInstancesAsync(List<String> processInstanceIds, String deleteReason) {
        return engine.getRuntimeService().deleteProcessInstancesAsync(processInstanceIds, deleteReason);
    }
```

-   multiple process instances can be canceled, sync or async
-   when cancelling process instances, it can be specified if custom listeners and i/o mapping should be skipped
-   cancelling processes asynchronously allows use of queries

###### CamundaClient (Camunda 8)

```java
    public CancelProcessInstanceResponse cancelProcessInstance(Long processInstanceKey) {
        return camundaClient.newCancelInstanceCommand(processInstanceKey)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   only one instance can be cancelled at a time
-   process instance is cancelled via _processInstanceKey_

---

#### Correlate Messages

The following patterns focus on methods how to correlate messages in Camunda 7 and how they convert to Camunda 8.

###### ProcessEngine (Camunda 7)

```java
    public void correlateMessage(String messageName, String businessKey, VariableMap variableMap) {
        engine.getRuntimeService().correlateMessage(messageName, businessKey, variableMap);
    }
```

-   correlates to a message subscription of a running process instance with given business key
-   can start new process instance with message start event

```java
    public void correlateMessageToOneExecution(String messageName, String executionId, VariableMap variableMap) {
        engine.getRuntimeService().messageEventReceived(messageName, executionId, variableMap);
    }
```

-   programmatically tells an execution that a message event has been received

```java
    public void correlateMessageViaBuilder(String messageName, String businessKey, String tenantId, VariableMap variableMap) {
        engine.getRuntimeService().createMessageCorrelation(messageName)
                .processInstanceBusinessKey(businessKey)
                .tenantId(tenantId)
                .setVariables(variableMap)
                .correlate();
    }
```

-   tenantId only possible via sync builder pattern
-   various _correlate...()_ methods possible to achieve different outcomes

```java
    public Batch correlateMessagesViaBuilderAsync(String messageName, List<String> processInstanceId, VariableMap variableMap) {
        return engine.getRuntimeService().createMessageCorrelationAsync(messageName)
                .processInstanceIds(processInstanceId)
                .setVariables(variableMap)
                .correlateAllAsync();
    }
```

-   correlates multiple messages asynchronously, various queries possible

###### CamundaClient (Camunda 8)

```java
    public CorrelateMessageResponse correlateMessage(String messageName, String correlationKey, Map<String, Object> variableMap) {
        return camundaClient.newCorrelateMessageCommand()
                .messageName(messageName)
                .correlationKey(correlationKey)
                .variables(variableMap)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

```java
    public PublishMessageResponse publishMessage(String messageName, String correlationKey, String messageId, Map<String, Object> variableMap) {
        return camundaClient.newPublishMessageCommand()
                .messageName(messageName)
                .correlationKey(correlationKey)
                .messageId(messageId)
                .timeToLive(Duration.ofSeconds(30000L))
                .variables(variableMap)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   no business key in Camunda 8.8
-   when correlating a message, the message is not buffered
-   a published message can be buffered by specifying a time to live
-   the messageId can be used to differentiate between different buffered message
-   messages are correlated once to a process based on BPMN process id (processDefinitionId), but can be correlated to different processes
-   for more information, see [the docs](https://docs.camunda.io/docs/next/components/concepts/messages)

---

#### Handle Variables

The following patterns focus on methods how to handle variables in Camunda 7 and how they convert to Camunda 8.

###### Getting Variables

###### ProcessEngine (Camunda 7)

```java
    public Object getVariableJavaObjectAPI(String executionId, String variableName) {
        return engine.getRuntimeService().getVariable(executionId, variableName);
    }
```

```java
    public TypedValue getVariableTypedValueAPI(String executionId, String variableName) {
        return engine.getRuntimeService().getVariableTyped(executionId, variableName);
    }
```

```java
    public Map<String, Object> getVariablesJavaObjectAPI(String executionId, List<String> variableNames) {
        return engine.getRuntimeService().getVariables(executionId, variableNames);
    }
```

```java
    public VariableMap getVariablesTypedValueAPI(String executionId, List<String> variableNames) {
        return engine.getRuntimeService().getVariablesTyped(executionId, variableNames, true);
    }
```

###### CamundaClient (Camunda 8)

```java
    public Variable getVariable(Long processInstanceKey, String variableName) {
        return camundaClient.newVariableSearchRequest()
                .filter(variableFilter -> variableFilter.processInstanceKey(processInstanceKey).name(variableName))
                .send()
                .join() // add reactive response and error handling instead of join()
                .items()
                .get(0);
    }
```

```java
    public List<Variable> getVariables(Long processInstanceKey, List<String> variableNames) {
        return camundaClient.newVariableSearchRequest()
                .filter(variableFilter -> variableFilter.processInstanceKey(processInstanceKey).name(name -> name.in(variableNames)))
                .send()
                .join() // add reactive response and error handling instead of join()
                .items();
    }
```

-   various filter, sorting and pagination options
-   for more information, see [the docs](https://docs.camunda.io/docs/next/apis-tools/camunda-api-rest/specifications/search-variables/)

###### Setting Variables

###### ProcessEngine (Camunda 7)

###### Java Object API

```java
    public void setVariableJavaObjectAPI(String executionId, int amount) {
        engine.getRuntimeService().setVariable(executionId, "amount", amount);
    }
```

```java
    public void setVariableTypedValueAPI(String executionId, int amount) {
        IntegerValue amountTyped = Variables.integerValue(amount);
        engine.getRuntimeService().setVariable(executionId, "amount", amountTyped);
    }
```

```java
    public void setVariablesJavaObjectAPI(String executionId, Map<String, Object> variableMap) {
        engine.getRuntimeService().setVariables(executionId, variableMap);
    }
```

```java
    public void setVariablesTypedValueAPI(String executionId, int amount, String name) {
        IntegerValue amountTyped = Variables.integerValue(amount);
        StringValue nameTyped = Variables.stringValue(name);
        VariableMap variableMap = Variables.createVariables().putValueTyped("amount", amountTyped);
        variableMap.putValueTyped("name", nameTyped);
        engine.getRuntimeService().setVariables(executionId, variableMap);
    }
```

```java
    public Batch setVariablesAsyncJavaObjectAPI(List<String> processInstanceIds, Map<String, Object> variableMap) {
        return engine.getRuntimeService().setVariablesAsync(processInstanceIds, variableMap);
    }
```

```java
    public Batch setVariablesAsyncTypesValueAPI(List<String> processInstanceIds, int amount, String name) {
        IntegerValue amountTyped = Variables.integerValue(amount);
        StringValue nameTyped = Variables.stringValue(name);
        VariableMap variableMap = Variables.createVariables().putValueTyped("amount", amountTyped);
        variableMap.putValueTyped("name", nameTyped);
        return engine.getRuntimeService().setVariablesAsync(processInstanceIds, variableMap);
    }
```

-   async: multiple variables can be set for multiple process instances
-   async: various ProcessInstanceQueries possible

###### CamundaClient (Camunda 8)

```java
    public SetVariablesResponse setVariable(Long elementInstanceKey, int amount) {
        return camundaClient.newSetVariablesCommand(elementInstanceKey)
                .variable("amount", amount)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

```java
    public SetVariablesResponse setVariables(Long elementInstanceKey, Map<String, Object> variableMap) {
        return camundaClient.newSetVariablesCommand(elementInstanceKey)
                .variables(variableMap)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   only one element instance can be updates at a time
-   _elementInstanceKey_ can describe any process instance, scope or activity

###### Setting and Getting a Custom Object

###### Process Engine (Camunda 7)

###### Getting a Custom Object Variable

```java
    public CustomObject getCustomVariableJavaObjectAPI(String executionId, String customVariableName) {
        return (CustomObject) engine.getRuntimeService().getVariable(executionId, customVariableName);
    }
```

```java
    public CustomObject getCustomVariableTypedValuetAPI(String executionId, String customVariableName) {
        ObjectValue objectValue = engine.getRuntimeService().getVariableTyped(executionId, customVariableName);
        return (CustomObject) objectValue.getValue();
    }
```

###### Setting a Custom Object Variable

```java
    public void setCustomVariableJavaObjectAPI(String executionId, CustomObject customObject) {
        engine.getRuntimeService().setVariable(executionId, "customObject", customObject);
    }
```

```java
    public void setCustomVariableTypedValueAPI(String executionId, CustomObject customObject) {
        ObjectValue objectValue = Variables.objectValue(customObject).create();
        engine.getRuntimeService().setVariable(executionId, "customObject", objectValue);
    }
```

###### CamundaClient (Camunda 8)

###### Getting a Custom Object Variable

```java
    public CustomObject getCustomVariable(Long processInstanceKey, String customVariableName) throws JsonProcessingException {
        Variable variable = camundaClient.newVariableSearchRequest()
                .filter(variableFilter -> variableFilter.processInstanceKey(processInstanceKey).name(customVariableName))
                .send()
                .join() // add reactive response and error handling instead of join()
                .items()
                .get(0);

        ObjectMapper mapper = new ObjectMapper();
        return mapper.readValue(variable.getValue(), CustomObject.class);
    }
```

-   the value is returned as a JSON string

###### Setting a Custom Object Variable

```java
    public SetVariablesResponse setCustomVariable(Long elementInstanceKey, CustomObject customObject) {
        return camundaClient.newSetVariablesCommand(elementInstanceKey)
                .variable("customObject", customObject)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   the object can directly be added here

###### Deleting Variables

Deleting variables is not possible in Camunda 8.8. You can set a variable to null or empty string.

---

#### Handle Resources

The following patterns focus on methods how to handle resources in Camunda 7 and how they convert to Camunda 8.

###### Deploy Resources via Annotation

###### ProcessEngine (Camunda 7)

```java
@SpringBootApplication
@EnableProcessApplication
public class Application {

    public static void main(String... args) {
        SpringApplication.run(Application.class, args);
    }
}
```

-   the annotation `@EnableProcessApplication` alongside a meta-data description `META-INF/processes.xml` takes care of deploying (and undeploying) the resources
-   for more information, see the docs [here](https://docs.camunda.org/manual/latest/user-guide/spring-boot-integration/process-applications/) and [here](https://docs.camunda.org/manual/latest/user-guide/process-applications/the-processes-xml-deployment-descriptor/)

###### CamundaClient (Camunda 8)

```java
@SpringBootApplication
@Deployment(resources = "classpath*:/bpmn/**/*.bpmn")
public class ProcessPaymentsApplication {

	public static void main(String[] args) {
		SpringApplication.run(ProcessPaymentsApplication.class, args);
	}
}
```

-   the annotation `@Deployment` can be used to specify specific files or multiple resources via a wildcard pattern to be deployed to the engine
-   for more information, see [the docs](https://docs.camunda.io/docs/next/apis-tools/spring-zeebe-sdk/getting-started/#deploy-process-models)

###### Deploy BPMN Model

###### ProcessEngine (Camunda 7)

```java
    public Deployment deployBPMNModel(String tenantId, String bpmnModelName, BpmnModelInstance bpmnModelInstance) {
        return engine.getRepositoryService().createDeployment()
                .tenantId(tenantId)
                .addModelInstance(bpmnModelName, bpmnModelInstance)
                .deploy();
    }
```

###### CamundaClient (Camunda 8)

```java
    public DeploymentEvent deployBPMNModel(String tenantId, String bpmnModelName, BpmnModelInstance bpmnModelInstance) {
        return camundaClient.newDeployResourceCommand()
                .addProcessModel(bpmnModelInstance, bpmnModelName)
                .send()
                .join();
    }
```

###### Deploy Multiple Resources by Filename

###### ProcessEngine (Camunda 7)

```java
    public Deployment deployMultipleResourcesByFileName(String fileName1, String fileName2) {
        return engine.getRepositoryService().createDeployment()
                .addClasspathResource(fileName1)
                .addClasspathResource(fileName2)
                .deploy();
    }
```

###### CamundaClient (Camunda 8)

```java
    public DeploymentEvent deployMultipleResourcesByFileName(String fileName1, String fileName2) {
        return camundaClient.newDeployResourceCommand()
                .addResourceFromClasspath(fileName1)
                .addResourceFromClasspath(fileName2)
                .send()
                .join();
    }
```

###### Delete Process Definition

###### ProcessEngine (Camunda 7)

```java
    public void deleteProcessDefinition(String processDefinitionId) {
        engine.getRepositoryService().deleteProcessDefinition(processDefinitionId);
    }
```

###### CamundaClient (Camunda 8)

```java
    public DeleteResourceResponse deleteProcessDefinition(Long processDefinitionKey) {
        return camundaClient.newDeleteResourceCommand(processDefinitionKey)
                .send()
                .join();
    }
```

###### Get Decision Definition

###### ProcessEngine (Camunda 7)

```java
    public DecisionDefinition getDecisionDefinition(String decisionDefinitionId) {
        return engine.getRepositoryService().getDecisionDefinition(decisionDefinitionId);
    }
```

###### CamundaClient (Camunda 8)

```java
    public DecisionDefinition getDecisionDefinition(Long decisionDefinitionKey) {
        return camundaClient.newDecisionDefinitionGetRequest(decisionDefinitionKey)
                .send()
                .join();
    }
```

---

#### handle user tasks



---

#### Raise Incidents

The following patterns focus on methods how to raise incidents in Camunda 7 and how they convert to Camunda 8.

###### ProcessEngine (Camunda 7)

```java
    public Incident raiseIncident(String type, String executionId, String configuration, String message) {
        return engine.getRuntimeService().createIncident(type, executionId, configuration, message);
    }
```

-   incidents should be raised in the context of a [JavaDelegate](../java-spring-delegate/) or [External Task Worker](../java-spring-external-task-worker/)

###### CamundaClient (Camunda 8)

```java
    public FailJobResponse raiseIncident(Long jobKey, String errorMessage, Map<String, Object> variableMap) {
        return camundaClient.newFailCommand(jobKey)
                .retries(0)
                .errorMessage(errorMessage)
                .variables(variableMap)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   incidents should be raised in the context of a job worker, see code conversion examples for a [JavaDelegate](../java-spring-delegate/) or [External Task Worker](../java-spring-external-task-worker/)

---

#### Search Process Definitions

The following patterns focus on methods how to search for process definitions in Camunda 7 and how they convert to Camunda 8.

###### ProcessEngine (Camunda 7)

```java
    public List<ProcessDefinition> searchProcessDefinitions(String name) {
        return engine.getRepositoryService().createProcessDefinitionQuery()
                .processDefinitionName(name)
                .orderByTenantId()
                .list();
    }
```

-   various filter options, for more information, see the [API Mapping WebApp](https://camunda-community-hub.github.io/camunda-7-to-8-code-conversion/)

###### CamundaClient (Camunda 8)

```java
    public List<ProcessDefinition> searchProcessDefinitions(String name) {
        return camundaClient.newProcessDefinitionSearchRequest()
                .filter(processDefinitionFilter -> processDefinitionFilter.name(name))
                .sort(processDefinitionSort -> processDefinitionSort.tenantId())
                .send()
                .join()
                .items();
    }
```

---

#### Starting Process Instances

The following patterns focus on various methods to start process instances in Camunda 7 and how they convert to Camunda 8.

###### Parameter Mappings

| Description                                     | Camunda 7            | Camunda 8                           |
| ----------------------------------------------- | -------------------- | ----------------------------------- |
| The BPMN Model Identifier maintained in the xml | processDefinitionKey | processDefinitionId (bpmnProcessId) |
| A unique key returned on deployment             | processDefinitionId  | processDefinitionKey                |

###### By BPMN Model Identifier (latest version)

###### ProcessEngine (Camunda 7)

```java
    public ProcessInstance startProcessByBPMNModelIdentifier(String processDefinitionKey, VariableMap variableMap) {
        return engine.getRuntimeService().startProcessInstanceByKey(processDefinitionKey, variableMap);
    }
```

```java
    public ProcessInstance startProcessByBPMNModelIdentifierViaBuilder(String processInstanceKey, String businessKey, String tenantId, VariableMap variableMap) {
        return engine.getRuntimeService().createProcessInstanceByKey(processInstanceKey)
                .businessKey(businessKey)
                .processDefinitionTenantId(tenantId)
                .setVariables(variableMap)
                .execute();
    }
```

-   tenantId only possible via builder pattern
-   also possible to execute with variables in return (for synchronous part of process instance)

###### CamundaClient (Camunda 8)

```java
    public ProcessInstanceEvent startProcessByBPMNModelIdentifier(String processDefinitionId, Map<String, Object> variableMap, String tenantId) {
        return camundaClient.newCreateInstanceCommand()
                .bpmnProcessId(processDefinitionId)
                .latestVersion()
                .variables(variableMap)
                .tenantId(tenantId)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   no business key in Camunda 8.8
-   _.join()_ can be specified with a timeout to wait for the process instance to complete

###### By Key Assigned on Deployment (specific version)

###### ProcessEngine (Camunda 7)

```java
    public ProcessInstance startProcessByKeyAssignedOnDeployment(String processDefinitionId, String businessKey, VariableMap variableMap) {
        return engine.getRuntimeService().startProcessInstanceById(processDefinitionId, businessKey, variableMap);
    }
```

```java
    public ProcessInstance startProcessByKeyAssignedOnDeploymentViaBuilder(String processDefinitionId, String businessKey, String tenantId, VariableMap variableMap) {
        return engine.getRuntimeService().createProcessInstanceById(processDefinitionId)
                .businessKey(businessKey)
                .processDefinitionTenantId(tenantId)
                .setVariables(variableMap)
                .execute();
    }
```

-   tenantId only possible via builder pattern
-   also possible to execute with variables in return (for synchronous part of process instance)

###### CamundaClient (Camunda 8)

```java
    public ProcessInstanceEvent startProcessByKeyAssignedOnDeployment(Long processDefinitionKey, Map<String, Object> variableMap, String tenantId) {
        return camundaClient.newCreateInstanceCommand()
                .processDefinitionKey(processDefinitionKey)
                .variables(variableMap)
                .tenantId(tenantId)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   no business key in Camunda 8.8
-   _.join()_ can be specified with a timeout to wait for the process instance to complete

###### By Message (And ProcessDefinitionId)

###### ProcessEngine (Camunda 7)

```java
    public ProcessInstance startProcessByMessage(String messageName, String businessKey, VariableMap variableMap) {
        return engine.getRuntimeService().startProcessInstanceByMessage(messageName, businessKey, variableMap);
    }
```

```java
    public ProcessInstance startProcessByMessageAndProcessDefinitionId(String messageName, String processDefinitionId, String businessKey, VariableMap variableMap) {
        return engine.getRuntimeService().startProcessInstanceByMessageAndProcessDefinitionId(messageName, processDefinitionId, businessKey, variableMap);
    }
```

###### CamundaClient (Camunda 8)

```java
    public CorrelateMessageResponse startProcessByMessage(String messageName, String correlationKey, Map<String, Object> variableMap, String tenantId) {
        return camundaClient.newCorrelateMessageCommand()
                .messageName(messageName)
                .correlationKey(correlationKey)
                .variables(variableMap)
                .tenantId(tenantId)
                .send()
                .join(); // add reactive response and error handling instead of join()
    }
```

-   no specific method to start a process instance by message
-   no method to target a specific process definition
-   if the message is received by a message start event of a deployed process definition (latest version), a process instance is created
-   for more information, see [the docs on messages](https://docs.camunda.io/docs/next/components/concepts/messages/#message-correlation-overview)
-   no business key in Camunda 8.8
-   it is also possible to publish a message with a time to live

---

## Glue code

Whenever you define code that is executed when a process arrives at a specific state in the process, specifically JavaDelegates and external task workers.

In **Camunda 7**, code executed by a service task or listener can be organized in various ways. A common method is using a **JavaDelegate** for a spring-integrated engine, for which a bean implementing the JavaDelegate interface is referenced via an expression in the BPMN xml. Another method, that is closer to the architecture enforced in Camunda 8, is the **external task worker pattern**.

With the enforced remote engine architecture in **Camunda 8**, only the **external task worker pattern** can be used, utilizing so-called **job workers**.


### JavaDelegate (Spring) &#8594; Job Worker (Spring)

In Camunda 7, JavaDelegates are a common way to implement glue code. Very often, JavaDelegates are Spring beans and referenced via Expression language in the BPMN xml.

JavaDelegates run in the same context as the engine. In addition to the DelegateExecution class that provides an interface to interact with the running process instance, a JavaDelegate can also call all engine services, like the Runtime service.

The code conversion patterns for the JavaDelegate cover the most important methods how a JavaDelegate can interact with the running process instance:

-   getting and setting process variables
-   reporting a failure
-   raising an incident
-   throwing a BPMN error

There are often multiple methods that achieve the same result. The patterns try to capture as many examples as possible. Delegate code that accesses the engine services is not covered here. Please refer to the patterns for the engine services. In general, delegate code that utilizes engines services is more difficult to migrate to Camunda 8.


###### OpenRewrite recipe (WIP)

-   [Recipe "JavaDelegateSpringToZeebeWorkerSpring"](../recipes/src/main/java/org/camunda/migration/rewrite/recipes/glue/JavaDelegateSpringToZeebeWorkerSpring.java)
-   [Learn how to apply recipes](../recipes/)


#### Class-level Changes

###### Camunda 7: JavaDelegate

Each JavaDelegate is implemented as a Spring bean that implements the JavaDelegate interface. The execution code is added by overriding the _execute_ function. This provides the _DelegateExecution_ class to interact with the running process instance. The bean name is used in the BPMN xml to specify which JavaDeleate to execute.

```java
@Component
public class RetrievePaymentAdapter implements JavaDelegate {

    @Override
    public void execute(DelegateExecution execution) {
        // execution code
    }
}
```

###### Camunda 8: Job Worker

Job workers are implemented as methods in a Spring bean with arbitrary name. The method is annotated with the _@JobWorker_ annotation. In the annotation, the _type_ can be set, which is used in the BPMN xml to specify which job worker to execute. Alternatively, if the type is not set in the annotation, the method name is set as the type.

```java
@Component
public class RetrievePaymentWorker {

    @JobWorker(type = "retrievePaymentAdapter")
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        // execution code
    }
}
```

For more information on how to implement job workers, check [the docs](https://docs.camunda.io/docs/8.8/apis-tools/spring-zeebe-sdk/configuration/).

The code conversion patterns will not cover the above class-level changes between JavaDelegates and job workers. Instead, they focus on method-level changes.

---

#### Handling a BPMN error

This example focuses on throwing a BPMN error from a JavaDelegate and job worker. A BPMN error is thrown for a task or listener and caught by a BPMN catch event in the BPMN model. The BPMN error is used for business errors that require a change in the process flow, not for technical errors.

Check the [README](./README.md) for more details on class-level changes.

###### JavaDelegate (Spring) - (Camunda 7)

```java
    @Override
    public void execute(DelegateExecution execution) {
        execution.setVariable("transactionId", "TX12345");
        throw new BpmnError("My error code", "My error message");
    }
```

-   in JavaDelegates, variables can not be added to the _BPMNError()_ method. They need to be set separately

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter", fetchVariables={"amount"})
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        throw CamundaError.bpmnError("my error code", "my error message", Map.of("transactionId", "TX12345"));
    }
```

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        client.newThrowErrorCommand(job.getKey())
            .errorCode("my error code")
            .errorMessage("my error message")
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .join();
    }
```

-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        client.newThrowErrorCommand(job.getKey())
            .errorCode("my error code")
            .errorMessage("my error message")
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .exceptionally(t -> {
                throw new RuntimeException("Could not throw BPMN error: " + t.getMessage(), t);
            });
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

#### Handling a Failure

Execution code can fail, promting the engine to try again or raise an incident if no retries are left. This example focuses on throwing an exception from a JavaDelegate vs. throwing an exception from a job worker.

Check the [README](./README.md) for more details on class-level changes.

###### JavaDelegate (Spring) - (Camunda 7)

```java
    @Override
    public void execute(DelegateExecution execution) {
        try {
            // do something...
        } catch(Exception e) {
            execution.setVariable("transactionId", "TX12345");
            throw new ProcessEngineException("my error message", e);
        }
    }
```

-   variables cannot be added to the _ProcessEngineException_ and need to be set separately
-   the engine registers the exeception and either retries or raises an incident
-   JavaDelegates are run synchronously by default. On failure, the engine goes back to the last wait state, e.g., an async configuration or external task worker
-   to retry a specific JavaDelegate on failure, it needs to be set to asnyc before in the BPMN. With this, a retry time cycle can be specified for the executed delegate code, for example: R3/PT30S
-   the engine decrements the number of retries itself
-   once the retries are depleted, an incident is raised by the engine
-   engine configurations can be used to set a default retry behavior

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter")
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            throw CamundaError.jobError("My error message", Map.of("transactionId", "TX12345"), job.getRetries() - 1, Duration.ofSeconds(30));
        }
    }
```

-   the engine registers the exeception and either retries or raises an incident, depending on the number of retries left
-   the initial number of retries is set in the BPMN xml
-   the job worker handles decrementing the number of retries and the retry backoff strategy explicitely
-   the job can fail with variables to skip work in the next retry that was already done in a previous job run
-   for more information on failing a job in a controlled way, look at [the docs](https://docs.camunda.io/docs/next/apis-tools/spring-zeebe-sdk/configuration/#failing-jobs-in-a-controlled-way)

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(job.getRetries() - 1)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .retryBackoff(Duration.ofSeconds(30))
                .send()
                .join();
        }
    }
```

-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(job.getRetries() - 1)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .retryBackoff(Duration.ofSeconds(30))
                .send()
                .exceptionally(t -> {
                    throw new RuntimeException("Could not fail job: " + t.getMessage(), t);
                });
        }
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

#### Handling an Incident

If an execution code failure cannot be solved via retries, or if all retries are exhausted, an incident can be raised. This incident is visible in Cockpit (Camunda 7) and Operate (Camunda 8). It can be retried once the underlying cause of failure is solved.

Check the [README](./README.md) for more details on class-level changes.

###### JavaDelegate (Spring) - (Camunda 7)

```java
    @Override
    public void execute(DelegateExecution execution) {
        execution.setVariable("transactionId", "TX12345");
        execution.createIncident("someType", "someConfiguration", "someMessage");
    }
```

-   variables cannot be added to _createIncident_ and need to be set separately

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter")
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch (Exception e) {
            throw CamundaError.jobError("My error message", Map.of("transactionId", "TX12345"), 0, null, e);
        }
    }
```

-   raising an incident directly uses the same **fail job** API as handling a retryable failure
-   the number of retries is set to 0 to raise the incident
-   for more information on failing a job in a controlled way, look at [the docs](https://docs.camunda.io/docs/next/apis-tools/spring-zeebe-sdk/configuration/#failing-jobs-in-a-controlled-way)

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(0)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .send()
                .join();
        }
    }
```

-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(0)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .send()
                .exceptionally(t -> {
                    throw new RuntimeException("Could not raise incident: " + t.getMessage(), t);
                });
        }
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

#### Handling Process Variables

The basic interaction of execution code and a running process instance is getting and setting process variables.

Check the [README](./README.md) for more details on class-level changes.

###### JavaDelegate (Spring) - (Camunda 7)

###### Java Object API

```java
    @Override
    public void execute(DelegateExecution execution) {
        int amount = (int) execution.getVariable("amount");
        // do something...
        execution.setVariable("transactionId", "TX12345");
    }
```

###### Typed Value API

```java
    @Override
    public void execute(DelegateExecution execution) {
        IntegerValue typedAmount = execution.getVariableTyped("amount");
        int amount = typedAmount.getValue();
        // do something...
        StringValue typedTransactionId = Variables.stringValue("TX12345");
        execution.setVariable("transactionId", typedTransactionId);
    }
```

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter", fetchVariables={"amount"})
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        int amount = (int) job.getVariablesAsMap().get("amount");
        // do something...
        return Map.of("transactionId", "TX12345");
    }
```

-   _fetchVariables_ can be specified to restrict which variables are fetched from the process instance

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job, @Variable(name = "amount") int amount) {
        // do something...
        client.newCompleteCommand(job.getKey())
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .join();
    }
```

-   _@Variable_ can be used to fetch and cast a specific variable. For more information, see [the docs](https://docs.camunda.io/docs/next/apis-tools/spring-zeebe-sdk/configuration/#using-variable).
-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job, @Variable(name = "amount") int amount) {
        // do something...
        client.newCompleteCommand(job.getKey())
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .thenApply(jobResponse -> jobResponse)
            .exceptionally(t -> {
                throw new RuntimeException("Could not complete job: " + t.getMessage(), t);
            });
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

### External Task Worker (Spring) &#8594; Job Worker (Spring)

In Camunda 7, external task workers are a way to implement glue code. They are deployed independently from the engine. Thus, they cannot access the engine's services.

The code conversion patterns for the external task workers cover the most important methods how an external task worker can interact with the running process instance:

-   getting and setting process variables
-   reporting a failure
-   raising an incident
-   throwing a BPMN error

There are often multiple methods that achieve the same result. The patterns try to capture as many examples as possible. External task workers are often more easily migrated to job workers in Camunda 8, as the architecture is similar.

###### OpenRewrite recipe (WIP)

-   [Recipe "JavaDelegateSpringToZeebeWorkerSpring"](../recipes/src/main/java/org/camunda/migration/rewrite/recipes/glue/JavaDelegateSpringToZeebeWorkerSpring.java)
-   [Learn how to apply recipes](../recipes/)


#### Class-level Changes

###### Camunda 7: External Task Worker

External task workers can be implemented one per Java class, implementing the ExternalTaskHandler interface, similar to the JavaDelegate.

```java
@Configuration
@ExternalTaskSubscription("retrievePaymentAdapter")
public class RetrievePaymentHandler implements ExternalTaskHandler {

    @Override
    public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
        // execution code
    }

}
```

To define multiple external task workers per class, each external task worker method is annotated with _@Bean_ and _@ExternalTaskSubscription_. In this case, the _execute()_ method is implemented as a _lambda function_.

```java
@Configuration
public class RetrievePaymentWorker {

    @Bean
    @ExternalTaskSubscription("retrievePaymentAdapter")
    public ExternalTaskHandler retrievePaymentHandler() {
        return (externalTask, externalTaskService) -> {
            // execution code
        };
    }
}
```

In both cases, the external task worker is identified by the topic added to the _@ExternalTaskSubscription_ annotation. The topic is referenced in the BPMN xml.

###### Camunda 8: Job Worker

Job workers are implemented as methods in a Spring bean with arbitrary name. The method is annotated with the _@JobWorker_ annotation. In the annotation, the _type_ can be set, which is used in the BPMN xml to specify which job worker to execute. Alternatively, if the type is not set in the annotation, the method name is set as the type.

```java
@Component
public class RetrievePaymentWorker {

    @JobWorker(type = "retrievePaymentAdapter")
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        // execution code
    }
}
```

For more information on how to implement job workers, check [the docs](https://docs.camunda.io/docs/8.8/apis-tools/spring-zeebe-sdk/configuration/).

The code conversion patterns will not cover the above class-level changes between JavaDelegates and job workers. Instead, they focus on method-level changes.

---

#### Handling a BPMN error

This example focuses on throwing a BPMN error from a JavaDelegate and job worker. A BPMN error is thrown for a task or listener and caught by a BPMN catch event in the BPMN model. The BPMN error is used for business errors that require a change in the process flow, not for technical errors.

Check the [README](./README.md) for more details on class-level changes.

###### External Task Worker (Spring) - (Camunda 7)

###### Java Object API

```java
    @Override
    public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
        Map<String, Object> variableMap = Map.ofEntries(Map.entry("transactionId", "TX12345"));
        externalTaskService.handleBpmnError(externalTask, "my error code", "my error message", variableMap);
    }
```

-   Using the Java Object API, a _Map<String, Object>_ is used in the method to throw a BPMN error

###### Typed Value API

```java
    @Override
    public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
        StringValue typedTransactionId = Variables.stringValue("TX12345");
        VariableMap variableMap = Variables.putValueTyped("transactionId", typedTransactionId);
        externalTaskService.handleBpmnError(externalTask, "my error code", "my error message", variableMap);
    }
```

-   Using the Typed Value API, a _VariableMap_ is created using a typed value.

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter", fetchVariables={"amount"})
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        throw CamundaError.bpmnError("my error code", "my error message", Map.of("transactionId", "TX12345"));
    }
```

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        client.newThrowErrorCommand(job.getKey())
            .errorCode("my error code")
            .errorMessage("my error message")
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .join();
    }
```

-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        client.newThrowErrorCommand(job.getKey())
            .errorCode("my error code")
            .errorMessage("my error message")
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .exceptionally(t -> {
                throw new RuntimeException("Could not throw BPMN error: " + t.getMessage(), t);
            });
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

#### Handling a Failure

Execution code can fail, promting the engine to try again or raise an incident if no retries are left. This example focuses on throwing an exception from an external task worker vs. throwing an exception from a job worker.

Check the [README](./README.md) for more details on class-level changes.

###### External Task Worker (Spring) - (Camunda 7)

```java
    @Override
    public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
        try {
            // do something...
        } catch(Exception e) {
            Map<String, Object> variableMap = Map.ofEntries(
                Map.entry("transactionId", "TX12345")
            );
            externalTaskService.handleFailure(externalTask.getId(), "my error message", "my error details", externalTask.getRetries() - 1, 30000L, variableMap, null);
        }
    }
```

-   the engine registers the exeception and either retries or raises an incident
-   the retry configuration and backoff strategy is handled by the external task worker itself
-   _async before_ should not be added to the BPMN, an external task worker constitutes a wait state itself

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter")
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            throw CamundaError.jobError("My error message", Map.of("transactionId", "TX12345"), job.getRetries() - 1, Duration.ofSeconds(30));
        }
    }
```

-   the engine registers the exeception and either retries or raises an incident, depending on the number of retries left
-   the initial number of retries is set in the BPMN xml
-   the job worker handles decrementing the number of retries and the retry backoff strategy explicitely
-   the job can fail with variables to skip work in the next retry that was already done in a previous job run
-   for more information on failing a job in a controlled way, look at [the docs](https://docs.camunda.io/docs/next/apis-tools/spring-zeebe-sdk/configuration/#failing-jobs-in-a-controlled-way)

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(job.getRetries() - 1)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .retryBackoff(Duration.ofSeconds(30))
                .send()
                .join();
        }
    }
```

-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(job.getRetries() - 1)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .retryBackoff(Duration.ofSeconds(30))
                .send()
                .exceptionally(t -> {
                    throw new RuntimeException("Could not fail job: " + t.getMessage(), t);
                });
        }
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

#### Handling an Incident

If an execution code failure cannot be solved via retries, or if all retries are exhausted, an incident can be raised. This incident is visible in Cockpit (Camunda 7) and Operate (Camunda 8). It can be retried once the underlying cause of failure is solved.

Check the [README](./README.md) for more details on class-level changes.

###### JavaDelegate (Spring) - (Camunda 7)

```java
    @Override
    public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
        try {
            // do something...
        } catch(Exception e) {
            Map<String, Object> variableMap = Map.ofEntries(
                Map.entry("transactionId", "TX12345")
            );
            externalTaskService.handleFailure(externalTask.getId(), "my error message", "my error details", 0, 0L, variableMap, null);
        }
    }
```

-   with the retries set to 0, the engine raises an incident

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter")
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch (Exception e) {
            throw CamundaError.jobError("My error message", Map.of("transactionId", "TX12345"), 0, null, e);
        }
    }
```

-   raising an incident directly uses the same **fail job** API as handling a retryable failure
-   the number of retries is set to 0 to raise the incident
-   for more information on failing a job in a controlled way, look at [the docs](https://docs.camunda.io/docs/next/apis-tools/spring-zeebe-sdk/configuration/#failing-jobs-in-a-controlled-way)

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(0)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .send()
                .join();
        }
    }
```

-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job) {
        try {
            // do something...
        } catch(Exception e) {
            client.newFailCommand(job.getKey())
                .retries(0)
                .errorMessage("my error message")
                .variables(Map.of("transactionId", "TX12345"))
                .send()
                .exceptionally(t -> {
                    throw new RuntimeException("Could not raise incident: " + t.getMessage(), t);
                });
        }
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

#### Handling Process Variables

The basic interaction of execution code and a running process instance is getting and setting process variables.

Check the [README](./README.md) for more details on class-level changes.

###### JavaDelegate (Spring) - (Camunda 7)

###### Java Object API

```java
    @Override
    public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
        int amount = (int) externalTask.getVariable("amount");
        // do something
        Map<String, Object> variableMap = Map.ofEntries(
            Map.entry("transactionId", "TX12345")
        );
        externalTaskService.complete(externalTask.getId(), variableMap, null);
    }
```

###### Typed Value API

```java
    @Override
    public void execute(ExternalTask externalTask, ExternalTaskService externalTaskService) {
        IntegerValue typedAmount = externalTask.getVariableTyped("amount");
        int amount = typedAmount.getValue();
        // do something
        StringValue typedTransactionId = Variables.stringValue("TX12345");
        VariableMap variableMap = Variables.putValueTyped("transactionId", typedTransactionId);
        externalTaskService.complete(externalTask.getId(), variableMap, null);
    }
```

###### Job Worker (Spring) - (Camunda 8)

###### autoComplete = true (default)

```java
    @JobWorker(type = "retrievePaymentAdapter", fetchVariables={"amount"})
    public Map<String, Object> handleJob(JobClient client, ActivatedJob job) {
        int amount = (int) job.getVariablesAsMap().get("amount");
        // do something...
        return Map.of("transactionId", "TX12345");
    }
```

-   _fetchVariables_ can be specified to restrict which variables are fetched from the process instance

###### autoComplete = false (blocking)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job, @Variable(name = "amount") int amount) {
        // do something...
        client.newCompleteCommand(job.getKey())
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .join();
    }
```

-   _@Variable_ can be used to fetch and cast a specific variable. For more information, see [the docs](https://docs.camunda.io/docs/next/apis-tools/spring-zeebe-sdk/configuration/#using-variable).
-   _.send().join()_ is blocking and waits for the response from the cluster

###### autoComplete = false (reactive)

```java
    @JobWorker(type = "retrievePaymentAdapter", autoComplete = false)
    public void handleJob(JobClient client, ActivatedJob job, @Variable(name = "amount") int amount) {
        // do something...
        client.newCompleteCommand(job.getKey())
            .variables(Map.of("transactionId", "TX12345"))
            .send()
            .thenApply(jobResponse -> jobResponse)
            .exceptionally(t -> {
                throw new RuntimeException("Could not complete job: " + t.getMessage(), t);
            });
    }
```

-   without _.join()_, the method _.send()_ returns a non-blocking _CamundaFuture_. With _thenApply()_ and _exceptionally()_ the response can be processed
-   this non-blocking programming style is **recommended** by Camunda

---

## Test Code

Code written to test your solution, e.g. using JUnit.


### Camunda Platform Assert &#8594; Camunda Process Test (CPT)

Most tests for Camunda 7 use [Camunda Platform Assert](https://github.com/camunda/camunda-bpm-platform/tree/master/test-utils/assert) combined with JUnit for automated unit tests, whereas in Camunda 8 you will use [Camunda Process Test (CPT)](https://docs.camunda.io/docs/next/apis-tools/testing/getting-started/) (starting from version 8.8).


#### Complete Test Case

A typical test case includes:

- Bootstrapping the application (e.g. with Spring Boot as shown here)
- Starting a process instance via the client API
- Asserting key milestones such as:
  - Reaching user tasks
  - Completing the process
  - Validating variable values

Note: Distinguish between tests that rely on job workers and those that do not. See our [testing best practices](/components/best-practices/development/testing-process-definitions/) for more context and [Job Execution in Test Cases](./60-job.md) for details.

###### Camunda 7: 

This example starts a process instance, waits for a user task, completes it, and validates the result.

[View full source code](https://github.com/camunda-community-hub/camunda-7-to-8-code-conversion/blob/main/examples/process-solution-camunda-7/src/test/java/org/camunda/community/migration/example/ApplicationTest.java).

```java
import org.camunda.bpm.engine.runtime.ProcessInstance;
import org.camunda.bpm.engine.variable.Variables;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

import static org.camunda.bpm.engine.test.assertions.bpmn.BpmnAwareTests.assertThat;
import static org.camunda.bpm.engine.test.assertions.bpmn.BpmnAwareTests.task;
import static org.camunda.bpm.engine.test.assertions.bpmn.BpmnAwareTests.complete;
import static org.camunda.bpm.engine.test.assertions.bpmn.BpmnAwareTests.runtimeService;
import static org.camunda.bpm.engine.test.assertions.bpmn.BpmnAwareTests.findId;

@SpringBootTest
public class ApplicationTest {	
  @Test
  void testHappyPathWithUserTask() {
    ProcessInstance processInstance = runtimeService().startProcessInstanceByKey(
                "sample-process-solution-process",
                Variables.createVariables().putValue("x", 7));
    // assert / verify that we arrive in the user task with the name "Say hello to demo"
    assertThat(processInstance).isWaitingAt(findId("Say hello to demo"));
    // complete that task, so that the process instance advances
    complete(task());
    // Assert that it completed in the right end event, and that a Spring Bean hooked into the service task has written the expected process variable
    assertThat(processInstance).isEnded().hasPassed("Event_GreaterThan5");
    assertThat(processInstance).variables().containsEntry("theAnswer", 42);
  }
}
```

###### Camunda 8: 

Camunda 8 uses its client APIs and [Camunda Process Test (CPT)](https://docs.camunda.io/docs/next/apis-tools/testing/getting-started/) for the same test case.

 [View full source code](https://github.com/camunda-community-hub/camunda-7-to-8-code-conversion/blob/main/examples/process-solution-camunda-8/src/test/java/org/camunda/community/migration/example/ApplicationTest.java)

```java
import java.util.HashMap;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import io.camunda.client.CamundaClient;
import io.camunda.client.api.response.ProcessInstanceEvent;
import io.camunda.client.api.search.response.SearchResponse;
import io.camunda.client.api.search.response.UserTask;
import io.camunda.process.test.api.CamundaSpringProcessTest;

import static io.camunda.process.test.api.CamundaAssert.assertThat;
import static io.camunda.process.test.api.assertions.ElementSelectors.byName;
import static org.junit.jupiter.api.Assertions.assertEquals;

@SpringBootTest
@CamundaSpringProcessTest
public class ApplicationTest {

    @Autowired
    private CamundaClient client;

    @Test
    void testHappyPathWithUserTask() {
		HashMap<String, Object> variables = new HashMap<String, Object>();
		variables.put("x", 7);
		
		ProcessInstanceEvent processInstance = client.newCreateInstanceCommand()
				.bpmnProcessId("sample-process-solution-process")
				.latestVersion()
				.variables(variables)
				.send().join();    	
      
      assertThat(processInstance).hasActiveElements(byName("Say hello to demo"));
      
      // C7 convenience method is missing in Camunda 8 at the moment
      complete(task(processInstance));
      
      assertThat(processInstance).isCompleted()
      	.hasCompletedElements("Event_GreaterThan5");
      
      assertThat(processInstance).hasVariable("theAnswer", 42);
    }
```

This code requires custom utility methods (`task` and `complete`) to query tasks and simulate user task completion. 
See [User Task Assertions](./40-user-task.md) for details and a code sample.
Such convenience methods may be added to CPT itself over time.

---

#### Process Instance Assertions

###### Camunda 7

Camunda 7 provides fluent assertions via [Camunda Platform Assert](https://github.com/camunda/camunda-bpm-platform/tree/master/test-utils/assert), allowing you to check the current state of a process instance:

```java
@Test
void testProcessInstanceIsWaitingAtUserTask() {
  ProcessInstance processInstance = runtimeService()
    .startProcessInstanceByKey("example-process");

  assertThat(processInstance)
    .isNotEnded()
    .isWaitingAt("UserTask_1");
}
```

###### Camunda 8

Camunda 8 uses [Camunda Process Test (CPT)](https://docs.camunda.io/docs/next/apis-tools/testing/getting-started/) to check the state of a process instance. There are currently less utility methods (like `runtimeService()`) and tests rely on normal Spring behavior plus custom code.

In test cases you typically want blocking behavior for the client API, so use `send().join()`:

```java
@Autowired
CamundaClient client;

@Test
void testProcessInstanceIsWaitingAtUserTask() {
  ProcessInstanceEvent processInstance = client.newCreateInstanceCommand()
    .bpmnProcessId("example-process")
    .latestVersion()
    .send().join();

  assertThat(processInstance)
    .isActive()
    .hasActiveElements("UserTask_1");
}
```

[List of supported assertions](https://docs.camunda.io/docs/next/apis-tools/testing/assertions/).

---

#### Process Variable Assertions

###### Camunda 7

Camunda 7 provides a nested variable assertion:

```java
@Test
void testProcessVariable() {
  ProcessInstance processInstance = runtimeService()
    .startProcessInstanceByKey("example-process", Variables.putValue("x", 5));

  assertThat(processInstance)
    .variables()
    .containsEntry("x", 5);
}
```

You can also check variables at the end of the process:

```java
assertThat(processInstance)
  .isEnded()
  .variables()
  .containsEntry("result", "done");
```

###### Camunda 8

[Camunda Process Test (CPT)](https://docs.camunda.io/docs/next/apis-tools/testing/getting-started/) has direct support for assertions on the process instance level:

```java
@Test
void testProcessVariable() {
  Map<String, Object> variables = new HashMap<>();
  variables.put("x", 5);
  
  ProcessInstanceEvent processInstance = client.newCreateInstanceCommand()
    .bpmnProcessId("example-process")
    .latestVersion()
    .variables(variables)
    .send().join();

  assertThat(processInstance)
    .hasVariable("x", 5);   
}
```

You can also assert final output variables after completion:
```java
assertThat(processInstance)
  .isCompleted()
  .hasVariable("result", "done");
```

---

#### User Task Assertions

###### Camunda 7

You can assert that the process is waiting at a user task, and complete it using built-in helpers:

```java
@Test
void testUserTaskIsReachedAndCompleted() {
  ProcessInstance processInstance = runtimeService()
    .startProcessInstanceByKey("example-process");

  assertThat(processInstance)
    .isWaitingAt("UserTask_Approve");

  // Optionally assert task name or assignee
  assertThat(task())
    .hasName("Approve Request")
    .isAssignedTo("demo");

  complete(task());

  assertThat(processInstance)
    .hasPassed("UserTask_Approve")
    .isEnded();
}
```


###### Camunda 8

With [Camunda Process Test (CPT)](https://docs.camunda.io/docs/next/apis-tools/testing/getting-started/), you can use hasActiveElements() to assert the task is active. 
At the moment you need to use the normal client API to retrieve and complete tasks. Of course, you can easily built own utility methods for this.
Such utility methods might be added to CPT over time.

Note that you typically address elements by ID and not by name, which we do for illustration purposes here:

```java
@Test
void testUserTaskIsReachedAndCompleted() {
  ProcessInstanceEvent processInstance = client.newCreateInstanceCommand()
    .bpmnProcessId("example-process")
    .latestVersion()
    .send().join();

  assertThat(processInstance)
    .hasActiveElements(byName("Approve Request"));
      
  assertThat(UserTaskSelectors.byTaskName("Approve Request"))
    .isCreated()
    .hasName("Approve Request")
    .hasAssignee("demo");

  // Retrieve and complete task using custom methods
  UserTask task = task(processInstance);
  complete(task);

  assertThat(processInstance)
    .hasCompletedElements("UserTask_Approve")
    .isCompleted();
}
```

The following utility methods are used in this test case:

```java
  private void complete(UserTask task) {
        client.newUserTaskCompleteCommand(task.getUserTaskKey()).send().join();
	}

	private UserTask task(ProcessInstanceEvent processInstance) {
		SearchResponse<UserTask> tasks = client.newUserTaskSearchRequest()
		  	.filter((f) -> f.bpmnProcessId(processInstance.getBpmnProcessId()))
		  	.send().join();
		  assertEquals(1, tasks.items().size());
		  return tasks.items().get(0);
	}
```

---

#### Message Correlation

###### Camunda 7

In Camunda 7, you can correlate a message using runtimeService and then assert that the process advanced. You can provide multiple correlationKeys that must match process variables of the process instance.

```java
@Test
void testMessageCorrelation() {
  ProcessInstance instance = runtimeService()
    .startProcessInstanceByKey("message-process");

  assertThat(instance)
    .isWaitingAt("MessageCatchEvent");
    
  // Correlate message to waiting message event
	Map<String, Object> correlationKeys = //...
	runtimeService().correlateMessage("Message_Continue", correlationKeys);

  assertThat(instance)
    .hasPassed("MessageCatchEvent")
    .isEnded();
}
```

###### Camunda 8

Camunda 8 uses the client API to publish a message, and assertions are typically based on observing that the process moved forward. Note that the correlation is based on one single String - the correlationKey.

```java
@Test
void testMessageCorrelation() {
  ProcessInstanceEvent instance = client.newCreateInstanceCommand()
    .bpmnProcessId("message-process")
    .latestVersion()
    .send().join();

 assertThat(instance)
   .hasActiveElements("MessageCatchEvent");

  client.newPublishMessageCommand()
    .messageName("Message_Continue")
    .correlationKey("some-key")
    .send().join();

  // Wait or assert state transition
  assertThat(instance)
    .hasCompletedElements("MessageCatchEvent")
    .isCompleted();
}
```

---

#### Job Execution in Test Cases

###### Camunda 7

Camunda 7 provides control over job execution through the `managementService`, which is useful for timers, asynchronous continuations, or retries.


```java
@Test
void testTimerFires() {
  ProcessInstance instance = runtimeService()
    .startProcessInstanceByKey("timer-process");

  // Execute the pending job (e.g. a timer)
  Job timerJob = managementService.createJobQuery()
    .processInstanceId(instance.getId())
    .singleResult();

  managementService.executeJob(timerJob.getId());

  assertThat(instance)
    .hasPassed("TimerEvent")
    .isEnded();
}

```

You can also assert job retries and incidents:

```java
Job job = managementService.createJobQuery()
  .processInstanceId(instance.getId())
  .singleResult();

assertEquals(2, job.getRetries());
```

###### Camunda 8

Camunda 8 handles timers and async jobs in the job worker model, and does not expose them via the Client API as directly.

To test timer events or ensure the process continues, you generally wait for the engine to progress:

```java
@Test
void testTimerTriggered() {
  ProcessInstanceEvent instance = client.newCreateInstanceCommand()
    .bpmnProcessId("timer-process")
    .latestVersion()
    .send().join();

  assertThat(instance)
    .hasCompletedElements("TimerEvent")
    .isCompleted();
}
```

You might not want to execute any JobWorkers automatically, then you can disable those for your test case:

```java
@SpringBootTest(
	    properties = {
	    	      "camunda.client.worker.defaults.enabled=false" // disable all job workers
	    })
```

And execute jobs manually in your test, probably using this utility method:

```java
  private void completeJobs(final String jobType, final Map<String, Object> variables) {
    client
        .newWorker()
        .jobType(jobType)
        .handler((jobClient, job) -> jobClient.newCompleteCommand(job).variables(variables).send())
        .open();
  }
```

This way you can leave out job workers from test execution.

---
